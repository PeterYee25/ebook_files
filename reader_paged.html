<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <!-- JSZip for reading .epub (zip) files -->
    <title>Paged Reader – CleanSource v5</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    SpineIndex
    <script src="/lib/jszip.min.js"></script>

    <style>
        /* --- TTS word styling --- */



        .tts-word {
            white-space: pre-wrap;
        }

        .tts-current-word {
            background: yellow;
        }

        * {
            box-sizing: border-box;
        }

        hr.reader-sep-asterisks {
            border: 0;
            height: 1px;
            background: rgba(0,0,0,0.12);
            margin: 0.6rem 0;
            max-width: 60%;
            margin-left: auto;
            margin-right: auto;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #000000; /* black around the book */
            color: #222;
        }

        body {
            display: flex;
            align-items: stretch;
            justify-content: center;
        }

        /* Outer app shell: top toolbar + book area */
        #appShell {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
        }

        /* Flag system */

        
        #coverContainer {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 1rem;
            height: calc(100vh - 60px); 
        }
            

        

        /* Thin black strip at the very bottom of the frame, showing page number */
        #pageFooterBar {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 32px;
            background: #000000;
            border-top: 1px solid #333;
            color: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            pointer-events: none;
        }

        #pageFooterBar,
        .pageFooterBar,
        #pageIndicator,
        .page-indicator {
            display: none !important;
        }

        /* Area below the toolbar that holds the scalable book page */
        #bookFrame {
            flex: 1 1 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000000;
            background: transparent !important; /* previously #000000 */
            overflow: hidden;
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
            touch-action: pan-y;
            border-bottom: none !important;
        }

        #bookPage {
            aspect-ratio: 2 / 3; /* 6:9 */
            max-height: 90vh;
            max-width: 60vw;
        }




        #coverImage {
            aspect-ratio: 2 / 3; /* Enforce 6:9 ratio */
            max-height: 90vh;
            max-width: 60vw;
            object-fit: contain;
            display: block;
            margin: auto;
        }



        /* Static cover overlay – fill the entire book page */
        .static-cover {
            position: absolute;
            top: 7%;
            bottom: 6%;
            left: 5%;
            right: 5%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f7f3e8 !important;
            opacity: 1 !important;
            z-index: 9999;
            border: 2px solid red;
        }

        .static-cover-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0,0,0,0.6);
            opacity: 1 !important;
            mix-blend-mode: normal !important;
            filter: none !important;
        }

        /* Real pages (hidden until cover dismissed) */
        #pageInner {
            position: absolute;
            top: 7%;
            bottom: 6%;
            left: 5%;
            right: 5%;
            display: none;
            flex-direction: column;
            overflow: hidden;
            background: #f7f3e8;
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
            height: auto !important;
            min-height: auto !important;
            overflow-y: visible !important;
            overflow-x: visible !important;
        }

        /* Reader inside the text block */
        /*
            #readerShell {
            position: relative;
            flex: 1 1 auto;
            padding: 0;
            overflow: hidden;
            background: transparent;
            touch-action: auto;
            display: none;
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
        }
            */
        #readerShell {
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
            z-index: 10 !important;
            background: #fff !important;
            color: #222 !important;
        }


            #pageContainer::-webkit-scrollbar {
                display: none; 
            }


        #pageContainer {
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
            z-index: 10 !important;
            background: #fff !important;
            color: #222 !important;
        }
        /*
        #pageContainer, #pageContainer * {
            color: #e0e0e0 !important;
            background: transparent !important;
        } */
            #pageContainer, #pageContainer * {
                color: #222 !important;
                background: #fff !important;
            }


            /* Central, scalable headings */
            #pageContainer h1,
            #pageContainer h2,
            #pageContainer h3 {
                text-align: center;
            }

                #pageContainer h1 .tts-word,
                #pageContainer h2 .tts-word,
                #pageContainer h3 .tts-word {
                    display: inline;
                }

            #pageContainer h1 {
                font-size: 1.4em;
                font-weight: 700;
            }

            #pageContainer h2 {
                font-size: 1.25em;
                font-weight: 600;
                margin-top: 1.4rem;
                margin-bottom: 0.7rem;
            }

            #pageContainer h3 {
                font-size: 1.1em;
                font-weight: 600;
                margin-top: 1.2rem;
                margin-bottom: 0.5rem;
            }

                #pageContainer h1:first-child,
                #pageContainer h2:first-child,
                #pageContainer h3:first-child {
                    margin-top: 0.8rem;
                }

        /* Give the last element some breathing room above the footer bar */
        /*
        #pageContainer {
            padding: 0.5rem 0.75rem 2rem;
            display: none;
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
        }
            */
        #pageContainer {
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
            z-index: 10 !important;
            background: #fff !important;
            color: #222 !important;
        }

            #pageContainer > :last-child {
                margin-bottom: 2rem;
            }

        /* global scale variable */
        html {
            --readerFontScale: 1; /* 100% */
        }

        .bottom-bar {
            display: none !important;
        }

        .nav-button {
            padding: 0.35rem 0.9rem;
            border-radius: 999px;
            border: 1px solid #ccc;
            background: #ffffff;
            cursor: pointer;
            font-size: 0.85rem;
            min-width: 90px;
        }

            .nav-button:disabled {
                opacity: 0.4;
                cursor: default;
            }

        .image-placeholder {
            width: 100%;
            height: 2rem;
            background: #ddd;
            margin: 1rem 0;
            border-radius: 4px;
        }

        /* --- TOP BAR LAYOUT ------------------------------------------------- */

        .top-bar {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.35rem 0.8rem;
            border-bottom: 1px solid #222;
            background: #111;
            color: #f5f5f5;
            font-size: 0.8rem;
            gap: 0.5rem;
        }

        .top-left,
        .top-right {
            flex: 0 0 8px;
        }

        .top-center {
            flex: 1 1 auto;
            display: flex;
            justify-content: center;
            gap: 0.6rem;
            max-width: 480px;
            margin: 0 auto;
        }

        .page-indicator {
            font-variant-numeric: tabular-nums;
            opacity: 0.9;
            white-space: nowrap;
        }

        .status-pill {
            font-size: 0.75rem;
            padding: 0.1rem 0.5rem;
            border-radius: 999px;
            background: #333;
            color: #f5f5f5;
        }

        .small-button,
        .tts-button {
            padding: 0.25rem 0.7rem;
            border-radius: 999px;
            border: 1px solid #444;
            background: #222;
            color: #f5f5f5;
            cursor: pointer;
            font-size: 0.8rem;
            white-space: nowrap;
        }

            .small-button:disabled,
            .tts-button:disabled {
                opacity: 0.4;
                cursor: default;
            }

        /* TOC combo */
        .goto-select {
            background: #FFFCE5;
            border-radius: 999px;
            padding: 0.15rem 0.7rem;
            font-size: 0.85rem;
            min-width: 220px;
            max-width: 260px;
            flex-grow: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

            .goto-select option {
                font-size: 0.8rem;
            }

        /* FONT & SPEED strip */

        .switch-bar {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .switch-group {
            display: inline-flex;
            align-items: center;
            background: #FFFCE5;
            border-radius: 999px;
            padding: 0.1rem 0.35rem;
            gap: 0.2rem;
        }

            .switch-group .small-button {
                width: 22px;
                height: 22px;
                padding: 0;
                border-radius: 4px;
                border: none;
                background: transparent;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            }

        .switch-readout {
            padding: 0.1rem 0.55rem;
            border-radius: 999px;
            background: #000000;
            color: #ffffff;
            font-size: 0.8rem;
            min-width: 3.0rem;
            text-align: center;
        }

        .font-group .font-down {
            font-weight: 700;
            color: #c1121f;
        }

        .font-group .font-up {
            font-weight: 700;
            color: #0f6b2f;
        }

        .switch-group .small-button svg {
            display: block;
        }

        #slowerBtn,
        #fasterBtn {
            display: none !important;
        }

        .bottom-shell {
            flex: 0 0 auto;
            padding: 0.3rem 0.8rem;
            border-top: 1px solid #222;
            background: #000;
        }

        @media (max-width: 540px) {
            .top-center {
                flex-direction: column;
                align-items: center;
                gap: 0.4rem;
            }

            .switch-bar {
                flex-wrap: wrap;
                justify-content: center;
            }
        }
        /*
        #pageInner {
            display: none !important;
            opacity: 0 !important;
            pointer-events: none !important;
            visibility: hidden !important;
            background: transparent !important;
        }
            */
        #pageInner {
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
            z-index: 10 !important;
            background: #fff !important;
            color: #222 !important;
            flex: none !important;
        }

        html, body, #bookFrame, #bookPage, #pageInner, #readerShell, #pageContainer, .epub-page {
            background: none !important;
            background-image: none !important;
        }

        /* 1. Baseline protection */
        .epub-page {
            display: block;
            padding: 1.5rem;
            color: #222;
            font-size: 1rem;
            line-height: 1.6;
            visibility: visible !important;
            opacity: 1 !important;
            background: transparent !important;
            page-break-after: auto !important;
            border-bottom: none !important;
        }

            /* 2. Reset everything inside */
            .epub-page * {
                visibility: visible !important;
                opacity: 1 !important;
                color: inherit !important;
                font-size: inherit !important;
                line-height: inherit !important;
                page-break-after: auto !important;
                border-bottom: none !important;
            }

            .epub-page img {
                max-width: 100%;
                height: auto;
                display: block;
                margin: 1rem auto;
            }

            .epub-page img,
            #pageContainer img {
                max-width: 100% !important;
                height: auto !important;
                display: block !important;
                position: relative !important;
                float: none !important;
            }


    </style>
</head>
<body>

    <!--   flagged system             -->
    <div id="readerContent">
        <div id="coverContainer"></div>
        <div id="pageContainer" style="display:none;"></div>
    </div>

    <div id="appShell">
        <!-- Top toolbar (outside the page) -->
        <header class="top-bar">
            <div class="top-left"></div>

            <div class="top-center">
                <!-- TOC combo -->
                <select id="tocSelect" class="goto-select"></select>

                <!-- FONT + SPEED strip -->
                <div class="switch-bar">

                    <!-- FONT GROUP -->
                    <div class="switch-group font-group">
                        <button id="fontSmallerBtn"
                                class="small-button font-down"
                                title="Smaller text">
                            A
                        </button>

                        <span class="switch-readout" id="fontStatus">100%</span>

                        <button id="fontLargerBtn"
                                class="small-button font-up"
                                title="Larger text">
                            A
                        </button>
                    </div>

                    <!-- SPEED GROUP -->
                    <div class="switch-group speed-group">
                        <button id="speedDownBtn" class="small-button" title="Slower">
                            <svg width="20" height="20" viewBox="0 0 24 24" aria-hidden="true">
                                <path fill="#7f1d1d"
                                      d="M6 2h12v3l-4 5 4 5v3H6v-3l4-5-4-5V2z" />
                            </svg>
                        </button>

                        <span class="switch-readout" id="speedStatus">1.0×</span>

                        <button id="speedUpBtn" class="small-button" title="Faster">
                            <svg width="20" height="20" viewBox="0 0 24 24" aria-hidden="true">
                                <path fill="#14532d"
                                      d="M6 2h12v3l-4 5 4 5v3H6v-3l4-5-4-5V2z" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>

            <div class="top-right"></div>
        </header>

        <!-- Book area (black background, centered page) -->
        <div id="bookFrame" tabindex="0">
            <div id="bookPage">
                <div id="staticCover" class="static-cover">
                    <img id="staticCoverImg"
                         alt="Book Cover"
                         class="static-cover-image" />
                </div>

                <!-- Real book pages, initially hidden until cover is dismissed -->
                <div id="pageInner">
                    <main id="readerShell">
                        <!-- Actual page content -->
                        <div id="pageContainer"></div>
                    </main>
                </div>
            </div>

            <div id="pageFooterBar">
                <span class="page-indicator" id="pageIndicator">Page 1 / 1</span>
            </div>
        </div>
    </div>

    <script src="reader-paged.js"></script>
    <script src="lib/epub.js"></script>

    <script>
        /* ============================================================
           Consolidated EPUB reader script (merged + fixes)
           - Uses the older file structure as base and adds:
             * inlining EPUB CSS to preserve author formatting
             * coverClickHandler (skip broken spine pages -> title)
             * short-click TTS toggle on #pageContainer (300ms threshold)
             * debounce (350ms) to prevent rapid toggles
             * safeStartReading / safeStopReading wrappers (uses existing start/stop if present)
           - Note: this script is defensive and logs warnings if files/functions are missing.
           ============================================================ */

        const EPUB_PATH = "books/CleanSource-Paged.epub";
        //window.book = book;

        // DOM handles
        const tocSelect = document.getElementById("tocSelect");
        const pageContainer = document.getElementById("pageContainer");
        const pageIndicator = document.getElementById("pageIndicator");
        const fontStatus = document.getElementById("fontStatus");
        const speedStatus = document.getElementById("speedStatus");
        const staticCoverImg = document.getElementById("staticCoverImg");

        // EPUB state
        let epubZip = null;
        let epubSpine = [];
        let epubOpfPath = null;
        let currentSpineIndex = 0;
        let showingStaticCover = true;
        let firstTextSpineIndex = 0; // title page index (zero based)
        let epubToc = [];

        // -------------flagged system -----------------------//

        const spineFlags = {
            "titlepage.xhtml": "start",
            "index_split_000.html": "skip"
        };

        // Opening covers
        let coverShown = 0;       // 0 = cover visible, 1 = cover dismissed
        let titlePageShown = 0;   // 0 = title page not yet advanced, 1 = title page clicked
        let bookFrame = 0;
        let endnoteOpen = 0;

        // Font/speed
        let fontScale = 1.0;
        let ttsRate = 1.0;

        // TTS state & highlighting
        let synth = window.speechSynthesis || null;
        let currentUtterance = null;
        let isReading = false;
        let ttsActiveWords = [];
        let ttsCurrentSpan = null;

        // Flags (top-level state; accessible for debugging)
        window.openCoverFlag = 0;
        window.openTitleFlag = 0;
        window.TTSon = 0;
        window.endnoteFlag = 0;

        // Timing & click thresholds
        const SHORT_CLICK_MS = 300;
        const TTS_TOGGLE_DEBOUNCE_MS = 350;
        let _lastTtsToggleAt = 0;
        let _pointerDownTs = 0;

        /* -----------------flag system--------------*/

        
        function showCover(coverUrl) {
            const cover = document.getElementById('staticCover');
            const img = document.getElementById('staticCoverImg');

            if (img && coverUrl) {
                img.src = coverUrl;
            }

            if (cover) {
                cover.style.display = 'flex';
                cover.style.opacity = '1';
                cover.style.pointerEvents = 'auto';
            }

            // do NOT attach onclick here; coverClickHandler already does that
        }





        /* -----------------flagged system -------------------------*/

        function getFirstFlaggedPage(flag = "start") {
            for (let i = 0; i < epubSpine.length; i++) {
                const path = epubSpine[i].toLowerCase();
                if (spineFlags[path] === flag) {
                    return i;
                }
            }
            return 0; // fallback
        }

        /* ---------------- Helpers ---------------- */

        function resolveZipPath(opfPath, href) {
            const lastSlash = opfPath ? opfPath.lastIndexOf("/") : -1;
            const base = (lastSlash >= 0) ? opfPath.substring(0, lastSlash + 1) : "";
            return (base + href).replace(/\\/g, "/");
        }

        function isErrorPageHtml(doc) {
            if (!doc || !doc.body) return false;
            const rawText = doc.body.textContent || "";
            const text = rawText.replace(/\s+/g, " ").trim().toLowerCase();
            if (!text) return false;

            const strongMarkers = [
                "this page contains the following errors",
                "below is a rendering of the page up to the first error",
                "calibre, version",
                "epub parsing error",
                "error on line"
            ];

            const mildMarkers = [
                "epub error",
                "could not be rendered",
                "could not display this page"
            ];

            const hasStrong = strongMarkers.some(m => text.includes(m));
            const hasMild = mildMarkers.some(m => text.includes(m));
            const isShort = text.length < 1500;

            return hasStrong || (hasMild && isShort);
        }

        function injectReaderCss(doc) {
            if (!doc) return;
            const body = doc.body;
            if (!body) return;

            body.style.margin = "0";
            body.style.padding = "0.5rem 0.75rem";
            body.style.fontFamily = 'Georgia, "Times New Roman", serif';
            body.style.fontSize = "1rem";
            body.style.lineHeight = "1.5";
            body.style.backgroundColor = "#f7f3e8";

            const ps = body.querySelectorAll("p");
            ps.forEach((p, idx) => {
                p.style.margin = "0.6rem 0";
                p.style.textAlign = "justify";
                if (idx === 0) {
                    p.style.textIndent = "0";
                }
            });

            body.querySelectorAll('[class*="Mso"], [class*="mso"]').forEach(el => {
                el.style.margin = "0.4rem 0";
            });

            body.querySelectorAll('[style*="position:absolute"], [style*="position: absolute"]').forEach(el => {
                el.style.position = "static";
                el.style.left = "";
                el.style.top = "";
            });
        }

        /* ------------- Inline CSS helper --------------
           If a spine HTML references stylesheet links inside the EPUB,
           read the CSS from the ZIP and inline it as <style> before removing the link.
        ------------------------------------------------*/

        /* ----------------------FLAGGED SYSTEM _____________________________*/

        function showPage(index) {
            // Safety: clamp index
            if (index < 0) index = 0;
            if (index >= epubSpine.length) index = epubSpine.length - 1;

            // Use the real EPUB renderer
            currentSpineIndex = index;
            renderSpinePage(index);
        }

        window.showPage = showPage;



        async function inlineCssFromDoc(doc, zip, basePath, opfPath) {
            const links = Array.from(doc.querySelectorAll('link[rel="stylesheet"][href]'));
            for (const link of links) {
                try {
                    let href = link.getAttribute("href") || "";
                    href = href.replace(/^\.?\//, "");
                    const cssPath = (basePath ? basePath + href : (opfPath ? resolveZipPath(opfPath, href) : href)).replace(/\\/g, "/");
                    const file = zip.file(cssPath);
                    if (file) {
                        const cssText = await file.async("text");
                        const style = doc.createElement("style");
                        style.textContent = cssText;
                        link.parentNode.insertBefore(style, link);
                        link.remove();
                        continue;
                    } else {
                        // attempt with opf base resolution if not found
                        if (opfPath) {
                            const alt = resolveZipPath(opfPath, href);
                            const altFile = zip.file(alt);
                            if (altFile) {
                                const cssText = await altFile.async("text");
                                const style = doc.createElement("style");
                                style.textContent = cssText;
                                link.parentNode.insertBefore(style, link);
                                link.remove();
                                continue;
                            }
                        }
                    }
                    // if not found in zip, remove to avoid external fetch
                    link.remove();
                } catch (err) {
                    console.warn("inlineCssFromDoc error:", err);
                    try { link.remove(); } catch (e) { }
                }
            }
        }

        /* -------------- fixImagesInHtml (enhanced) --------------
           - Inlines EPUB CSS (maintains author styles)
           - Replaces image src with blob URLs if present in zip
           - Keeps old fallback image replacement behavior
        ----------------------------------------------------------- */
        async function fixImagesInHtml(htmlText, zip, basePath) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlText, "text/html");

            // Inline CSS from EPUB where possible
            try {
                await inlineCssFromDoc(doc, zip, basePath, epubOpfPath);
            } catch (err) {
                // ignore and continue
                console.warn("inlineCssFromDoc failed:", err);
            }

            // Remove favicons and known external page-only styles
            doc.querySelectorAll(
                'link[rel="icon"], ' +
                'link[href$="favicon.ico"], ' +
                'link[href$="page_styles.css"]'
            ).forEach(link => link.remove());

            const imgTags = doc.querySelectorAll("img[src]");

            for (const img of imgTags) {
                const origSrc = img.getAttribute("src");
                if (!origSrc) continue;

                if (/^(https?:)?\/\//i.test(origSrc) || origSrc.startsWith("data:")) {
                    continue;
                }

                let folder = basePath || "";
                if (folder && !folder.endsWith("/")) {
                    folder += "/";
                }

                const normalizedSrc = origSrc.replace(/^\.?\//, "");
                const zipPath = (folder + normalizedSrc).replace(/\\/g, "/");
                const fileInZip = zip.file(zipPath);

                if (!fileInZip) {
                    console.warn("[EPUB] image not found in zip, replacing with local PNG:", zipPath);

                    const replacementMap = {
                        "image.png": "covers/CleanSource-Paged_img1.png",
                        "image-1.png": "covers/CleanSource-Paged_img2.png"
                    };

                    const fileName = origSrc.split("/").pop();
                    const localReplacement = replacementMap[fileName];

                    if (localReplacement) {
                        const newImg = document.createElement("img");
                        newImg.src = localReplacement;
                        newImg.style.width = "100%";
                        newImg.style.display = "block";
                        newImg.style.margin = "1rem 0";
                        img.replaceWith(newImg);
                    } else {
                        const ph = document.createElement("div");
                        ph.className = "image-placeholder";
                        img.replaceWith(ph);
                    }

                    continue;
                }

                try {
                    const blob = await fileInZip.async("blob");
                    const localUrl = URL.createObjectURL(blob);
                    img.src = localUrl;
                } catch (err) {
                    console.warn("Error creating blob URL for image", zipPath, err);
                    const ph = document.createElement("div");
                    ph.className = "image-placeholder";
                    img.replaceWith(ph);
                }
            }

            // Apply reader's uniform CSS as a fallback (keeps layout consistent)
            injectReaderCss(doc);

            if (isErrorPageHtml(doc)) {
                const wrapper = document.createElement("div");
                wrapper.textContent =
                    "[This EPUB page contained a rendering error and was skipped.]";
                return wrapper.outerHTML;
            }

            return doc.body ? doc.body.innerHTML : "";
        }

        /* ----------------- Load EPUB ------------------ */
        async function loadEpubFile() {
            try {
                const response = await fetch(EPUB_PATH);
                if (!response.ok) throw new Error("Failed to fetch EPUB file: " + response.status);

                const arrayBuffer = await response.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);

                const containerFile = zip.file("META-INF/container.xml");
                if (!containerFile) throw new Error("META-INF/container.xml not found in EPUB");

                const containerXml = await containerFile.async("text");
                const parser = new DOMParser();
                const containerDoc = parser.parseFromString(containerXml, "application/xml");
                const rootfileEl = containerDoc.querySelector("rootfile");
                if (!rootfileEl) throw new Error("<rootfile> not found in container.xml");

                const opfPath = rootfileEl.getAttribute("full-path");
                if (!opfPath) throw new Error("No OPF full-path in container.xml");

                const opfFile = zip.file(opfPath);
                if (!opfFile) throw new Error("OPF file not found at " + opfPath);

                const opfText = await opfFile.async("text");
                const opfDoc = parser.parseFromString(opfText, "application/xml");

                const manifestById = new Map();
                opfDoc.querySelectorAll("manifest > item").forEach(item => {
                    const id = item.getAttribute("id");
                    const href = item.getAttribute("href");
                    if (id && href) manifestById.set(id, href);
                });

                const spinePaths = [];
                opfDoc.querySelectorAll("spine > itemref").forEach(itemref => {
                    const idref = itemref.getAttribute("idref");
                    const href = manifestById.get(idref);
                    if (href) {
                        const fullPath = resolveZipPath(opfPath, href);
                        spinePaths.push(fullPath);
                    }
                });

                if (!spinePaths.length) throw new Error("EPUB spine is empty");

                epubZip = zip;
                epubSpine = spinePaths;
                epubOpfPath = opfPath;

                buildToc();

                console.log("[EPUB] loaded. OPF:", opfPath, "spine length:", spinePaths.length);

                // Load static cover
                const bookName = EPUB_PATH.split("/").pop().replace(".epub", "");
                const coverUrl = `/covers/${bookName}_cover.png`;

                fetch(coverUrl, { method: "HEAD" })
                    .then(res => {
                        if (res.ok) {
                            staticCoverImg.src = coverUrl;
                        } else {
                            staticCoverImg.remove(); // prevent broken icon
                        }
                    })
                    .catch(() => staticCoverImg.remove());

                // *** CALL IT HERE ***
                showCover(staticCoverImg.src);

                return true;   // <-- VALID because inside function
            } catch (err) {
                console.error("EPUB load error:", err);
                return null;   // <-- VALID because inside function
            }
        }   // <-- THIS closes loadEpubFile() correctly

        /* ----------------- TOC ------------------ */
        async function buildToc() {
            epubToc = [];
            if (!epubZip || !epubSpine) return;

            for (let i = 0; i < epubSpine.length; i++) {
                const spinePath = epubSpine[i];
                const file = epubZip.file(spinePath);
                if (!file) continue;
                try {
                    const html = await file.async("text");
                    const doc = new DOMParser().parseFromString(html, "text/html");
                    const headings = doc.querySelectorAll("h1, h2, h3");
                    if (!headings.length) continue;
                    const levelCounters = { h1: 0, h2: 0, h3: 0 };
                    headings.forEach(h => {
                        const level = h.tagName.toLowerCase();
                        const label = h.textContent.trim();
                        const idxInLevel = levelCounters[level] ?? 0;
                        levelCounters[level] = idxInLevel + 1;
                        epubToc.push({
                            spineIndex: i,
                            level,
                            headingIndex: idxInLevel,
                            label
                        });
                    });
                } catch (err) {
                    console.warn("buildToc: failed to parse spine", i, err);
                }
            }
            populateTocDropdown();
        }

        function populateTocDropdown() {
            if (!tocSelect) return;
            tocSelect.innerHTML = "";
            epubToc.forEach((entry, idx) => {
                const opt = document.createElement("option");
                opt.value = String(idx);
                let prefix = "";
                if (entry.level === "h2") prefix = "  • ";
                if (entry.level === "h3") prefix = "    ▸ ";
                opt.textContent = prefix + entry.label;
                tocSelect.appendChild(opt);
            });
        }

        tocSelect.addEventListener("change", async () => {
            const idx = Number(tocSelect.value);
            if (Number.isNaN(idx)) return;
            const entry = epubToc[idx];
            if (!entry) return;
            if (showingStaticCover) hideStaticCoverIfNeeded();
            await renderSpinePage(entry.spineIndex);
            // scroll to heading
            const container = pageContainer;
            if (!container) return;
            let headings = container.querySelectorAll(entry.level);
            let target = headings[entry.headingIndex];
            if (!target) {
                target = Array.from(container.querySelectorAll("h1, h2, h3")).find(h => h.textContent.trim() === entry.label);
            }
            if (target) {
                target.scrollIntoView({ block: "center", behavior: "auto" });
            }
        });

        /* --------------- Render spine page --------------- */
        async function renderSpinePage(spineIndex) {


            console.log("[renderSpinePage] spineIndex:", spineIndex, "item:", epubSpine[spineIndex]);

            if (!epubZip || !epubSpine.length) {
                throw new Error("EPUB not initialised");
            }

            // Clamp index
            if (spineIndex < 0) spineIndex = 0;
            if (spineIndex >= epubSpine.length) spineIndex = epubSpine.length - 1;

            currentSpineIndex = spineIndex;

            const spinePath = epubSpine[spineIndex];
            const file = epubZip.file(spinePath);

            if (!file) {
                throw new Error("Spine item not found in ZIP: " + spinePath);
            }

            let htmlText = await file.async("text");
            // DEBUG: log the raw XHTML exactly as it exists inside the EPUB
            console.log("[DEBUG] RAW htmlText:", htmlText);

            const lastSlash = spinePath.lastIndexOf("/");
            const basePath = (lastSlash >= 0) ? spinePath.substring(0, lastSlash + 1) : "";

            const isTitlePage = spinePath.includes("index_split_000");

            try {
                console.log("[renderSpinePage] htmlText length:", htmlText?.length);
                htmlText = await fixImagesInHtml(htmlText, epubZip, basePath);
            } catch (err) {
                console.warn("Image fix failed:", err);
            }

            // Sanitize and wrap XHTML before injecting
            const temp = document.createElement('div');
            temp.innerHTML = htmlText;

            // Remove broken <img> tags
            temp.querySelectorAll('img').forEach(img => {
                if (!img.src || img.src.includes('cover.jpg')) {
                    img.remove();
                }
            });

            // Remove broken <image> tags only
            temp.querySelectorAll('image').forEach(img => {
                const href = img.getAttribute('xlink:href') || img.getAttribute('href');
                if (!href || href.trim() === "" || href.includes("*****")) {
                    img.remove();
                }
            });

            // Remove empty <svg> only if it has no children
            temp.querySelectorAll('svg').forEach(svg => {
                if (!svg.querySelector('image')) {
                    svg.remove();
                }
            });

            // ---------------------------------------------
            // DETECT AND SKIP IMAGE-ONLY PAGES (like titlepage.xhtml)
            // ---------------------------------------------
            const hasText = temp.textContent.trim().length > 0;
            const hasTextBlocks = temp.querySelector("p, h1, h2, h3, h4, h5, h6, li, blockquote");
            const hasImages = temp.querySelector("img, image, svg");

            const isImageOnly = hasImages && !hasText && !hasTextBlocks;

            if (isImageOnly) {
                console.log("[renderSpinePage] Skipping image-only page at spineIndex", spineIndex);
                return renderSpinePage(spineIndex + 1);
            }

            const container = document.getElementById('pageInner');
            if (!container) {
                console.error("[renderSpinePage] ERROR: pageInner not found in DOM");
                return;
            }

            // Inject sanitized XHTML into the dedicated container
            container.innerHTML = `<div class="epub-page">${temp.innerHTML}</div>`;
            console.log("[DEBUG] After inject, .epub-page exists:", container.querySelector(".epub-page"));
            const pageContainer = document.getElementById("pageContainer");

            if (isTitlePage) {
                pageContainer.classList.add("is-title-page");
            } else {
                pageContainer.classList.remove("is-title-page");
            }


            // make sure the frame is visible
            const pageInner = document.getElementById('pageInner');
            const readerShell = document.getElementById('readerShell');

            [pageInner, readerShell, container].forEach(el => {
                if (!el) return;
                el.style.display = 'block';
                el.style.opacity = '1';
                el.style.visibility = 'visible';
                el.style.pointerEvents = 'auto';
            });

            // keep bookFrame as flex container (don’t clear it)
            bookFrame = document.getElementById('bookFrame');
            if (bookFrame) {
                bookFrame.style.display = 'flex';
                bookFrame.scrollTop = 0;
                bookFrame.style.overflowY = (currentSpineIndex === firstTextSpineIndex)
                    ? 'hidden'
                    : 'auto';
            }


            // Scroll to top
            bookFrame.scrollTop = 0;

            // Overflow rules
            if (currentSpineIndex === firstTextSpineIndex) {
                bookFrame.style.overflowY = "hidden";
            } else {
                bookFrame.style.overflowY = "auto";
            }

            // Page indicator
            if (!showingStaticCover && pageIndicator) {
                pageIndicator.textContent = `Page ${spineIndex + 1} / ${epubSpine.length}`;
            }


            [pageInner, readerShell, pageContainer].forEach(el => {
                if (el) {
                    el.style.removeProperty('display');
                    el.style.opacity = '1';
                    el.style.pointerEvents = 'auto';
                    el.style.visibility = 'visible';
                }
            });

            bookFrame = document.getElementById("bookFrame");
            if (bookFrame) {
                bookFrame.focus();
            }
        }


        async function goNextPage() {
            if (showingStaticCover) {
                hideStaticCoverIfNeeded();
                return;
            }
            if (currentSpineIndex === firstTextSpineIndex) {
                if (currentSpineIndex < epubSpine.length - 1) {
                    safeStopReading();
                    await renderSpinePage(currentSpineIndex + 1);
                }
                return;
            }
            if (pageContainer) {
                const visible = pageContainer.clientHeight;
                const top = pageContainer.scrollTop;
                const total = pageContainer.scrollHeight;
                const remaining = total - (top + visible);
                const THRESHOLD = 10;
                if (remaining > THRESHOLD) {
                    pageContainer.scrollBy({
                        top: visible * 0.9,
                        behavior: "smooth"
                    });
                    return;
                }
            }
            if (!epubSpine.length) return;
            if (currentSpineIndex >= epubSpine.length - 1) return;
            safeStopReading();
            await renderSpinePage(currentSpineIndex + 1);

            const pageInner = document.getElementById('pageInner');
            const readerShell = document.getElementById('readerShell');
            const pageContainer = document.getElementById('pageContainer');
            [pageInner, readerShell, pageContainer].forEach(el => {
                if (!el) return;

                el.style.removeProperty('display');
                el.style.opacity = '1';
                el.style.pointerEvents = 'auto';
                el.style.visibility = 'visible';
            });
        }

        async function goPrevPage() {
            if (showingStaticCover) return;
            if (currentSpineIndex === firstTextSpineIndex) {
                const cover = document.getElementById("staticCover");
                const pageInner = document.getElementById("pageInner");
                if (cover) cover.style.display = "flex";
                if (pageInner) pageInner.style.display = "none";
                showingStaticCover = true;
                if (pageIndicator) {
                    pageIndicator.textContent = "Cover";
                }
                return;
            }
            if (pageContainer) {
                const visible = pageContainer.clientHeight;
                const top = pageContainer.scrollTop;
                const THRESHOLD = 10;
                if (top > THRESHOLD) {
                    pageContainer.scrollBy({
                        top: -visible * 0.9,
                        behavior: "smooth"
                    });
                    return;
                }
            }
            if (!epubSpine.length) return;
            if (currentSpineIndex <= 0) return;
            safeStopReading();
            await renderSpinePage(currentSpineIndex - 1);
        }


        // Fallback to a simple SpeechSynthesis reading of the visible page text (no per-word highlight)


        function safeStopReading() {
            if (typeof window.stopReading === "function") {
                try {
                    window.stopReading();
                    window.TTSon = 0;
                    return;
                } catch (err) {
                    console.warn("stopReading() threw:", err);
                }
            }
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }
            window.TTSon = 0;
        }

        /* --------------- hide static cover --------------- */
        function hideStaticCoverIfNeeded() {
            if (!showingStaticCover) return;
            const cover = document.getElementById("staticCover");
            const pageInner = document.getElementById("pageInner");
            if (cover) cover.remove();
            if (pageInner) pageInner.style.display = "flex";
            showingStaticCover = false;
            if (epubSpine && epubSpine.length && pageIndicator) {
                pageIndicator.textContent = `Page ${currentSpineIndex + 1} / ${epubSpine.length}`;
            }
        }

        /* --------------- cover click handler (skip broken pages) --------------- */
        async function coverClickHandler(e) {
            try {
                if (!showingStaticCover) return;
                if (window.endnoteFlag) return;
                window.openCoverFlag = 1;
                hideStaticCoverIfNeeded();

                if (!epubZip || !epubSpine || !epubSpine.length) {
                    // If no spine yet, nothing to do
                    return;
                }

                const startIdx = (typeof firstTextSpineIndex === "number") ? firstTextSpineIndex : 0;
                for (let i = startIdx; i < epubSpine.length; i++) {
                    try {
                        const spinePath = epubSpine[i];
                        const file = epubZip.file(spinePath);
                        if (!file) continue;
                        const html = await file.async("text");
                        const lastSlash = spinePath.lastIndexOf("/");
                        const basePath = (lastSlash >= 0) ? spinePath.substring(0, lastSlash + 1) : "";
                        const fixed = await fixImagesInHtml(html, epubZip, basePath);
                        if (typeof fixed === "string" && fixed.includes("[This EPUB page contained a rendering error")) {
                            continue; // skip broken
                        }
                        // render this spine
                        await renderSpinePage(i);
                        window.openTitleFlag = (i === startIdx) ? 1 : 0;
                        return;
                    } catch (err) {
                        console.warn("coverClickHandler: skipping spine due to error", err);
                        continue;
                    }
                }

                // fallback
                await renderSpinePage(startIdx);
                window.openTitleFlag = 1;
            } catch (err) {
                console.error("coverClickHandler error:", err);
            }
        }


        /* attach cover handler */
        (function attachCover() {
            const coverEl = document.getElementById("staticCover");
            if (!coverEl) return;
            try { coverEl.removeEventListener("click", coverClickHandler); } catch (e) { }
            coverEl.addEventListener("click", coverClickHandler, { passive: true });
        })();

        /* --------------- page click: short-click detection & TTS toggle --------------- */
        (function attachPageClickBehavior() {
            const pageEl = document.getElementById("pageContainer");
            if (!pageEl) {
                console.warn("attachPageClickBehavior: #pageContainer not found");
                return;
            }

            pageEl.addEventListener("pointerdown", (ev) => {
                _pointerDownTs = Date.now();
            }, { passive: true });

            pageEl.addEventListener("pointerup", async (ev) => {
                const down = _pointerDownTs || 0;
                _pointerDownTs = 0;
                const dt = Date.now() - down;

                // only consider short clicks
                if (dt <= 0 || dt > SHORT_CLICK_MS) return;

                // respect endnote overlay
                if (window.endnoteFlag) return;

                // ignore clicks on interactive inner elements
                if (ev.target && ev.target.closest && ev.target.closest("a, button, input, textarea, select")) {
                    return;
                }

                // if cover visible, treat as cover click
                if (showingStaticCover) {
                    await coverClickHandler();
                    return;
                }

                // title page -> advance (no TTS toggle)
                if (currentSpineIndex === firstTextSpineIndex) {
                    if (typeof goNextPage === "function") {
                        try { await goNextPage(); } catch (err) { console.warn(err); }
                    }
                    return;
                }

                // content pages: toggle TTS with debounce
                const now = Date.now();
                if (now - _lastTtsToggleAt < TTS_TOGGLE_DEBOUNCE_MS) return;
                _lastTtsToggleAt = now;

                if (window.TTSon) {
                    safeStopReading();
                } else {
                    safeStartReading();
                }
            }, { passive: true });

            // block dblclick default
            pageEl.addEventListener("dblclick", (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
            }, { passive: true });
        })();

        
        /* ---------------- Initialization ---------------- */
        (async function initReader() {
            if (staticCoverImg) {
                staticCoverImg.style.display = "block";
            }

            await loadEpubFile();
            firstTextSpineIndex = epubSpine.findIndex(path =>
                path.includes("index_split_000")
            );

            if (pageIndicator) {
                pageIndicator.textContent = "Cover";
            }

            document.addEventListener("click", (e) => {
                // 1) COVER CLICK
                const cover = e.target.closest(".static-cover");
                if (cover && coverShown === 0) {
                    console.log("[Cover] Click → show title page");
                    coverShown = 1;
                    titlePageShown = 0;

                    cover.style.display = "none";

                    const pageInner = document.getElementById("pageInner");
                    if (pageInner) {
                        pageInner.style.display = "flex";
                        pageInner.style.opacity = "1";
                        pageInner.style.visibility = "visible";
                    }

                    renderSpinePage(firstTextSpineIndex);
                    return;
                }

                // 2) TITLE PAGE CLICK
                if (
                    coverShown === 1 &&
                    titlePageShown === 0 &&
                    currentSpineIndex === firstTextSpineIndex
                ) {
                    console.log("[TitlePage] Click → go to preface");
                    titlePageShown = 1;
                    renderSpinePage(firstTextSpineIndex + 1);
                    return;
                }
            });

            // Scrolling function
            document.addEventListener("wheel", (e) => {
                if (endnoteOpen === 1 || titlePageShown === 0) {
                    e.preventDefault();
                    return;
                }
            });
            document.addEventListener("keydown", (e) => {
                if (e.key === "ArrowUp" || e.key === "ArrowDown") {
                    if (endnoteOpen === 1 || titlePageShown === 0) {
                        e.preventDefault();
                        return;
                    }
                }
            });

        })();



    </script>
    <!-- Load epub.js from /lib -->

</body>
</html>